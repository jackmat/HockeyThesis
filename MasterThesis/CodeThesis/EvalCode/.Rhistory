eliminateRep<- as.character(RepeatedPlayers$UniquePlayers)
RemoveRep <- select(Data, -contains("_")) %>% select(-one_of(eliminateRep))
## The warning is OK
EndData<-cbind(RemoveRep, Res)
colnames(EndData)[2:length(colnames(EndData))]<-
substr(colnames(EndData)[2:length(colnames(EndData))],2,8)
return(EndData)
}
Choosedif0<-function(x){
#### It takes a vector of two numbers and
#### It gives out the one different to 0 if possible
col1<- as.numeric(x[1])
col2<- as.numeric(x[2])
if(length(x)==3){
col3 <- as.numeric(x[3])
}
else{col3<- rep(0, length(col1))}
if(col1==0 & col2==0 & col3==0){return(as.numeric(0))}
else if(col1!=0 & col2==0 & col3 == 0){return(col1)}
else if(col2!=0 & col1==0 & col3 == 0){return(col2)}
else if(col1==0 & col2==0 & col3 != 0){return(col3)}
else{return(max(c(col1,col2, col3)))}
}
JoinPlayersValuesIntoOneCol<- function(myData){
n<-length(colnames(myData))
Datas <- myData[,2:n] # dropoutCols<- c("X")
FilteredFrame<- Datas %>%
filter(CountGame <=RegMatches) %>%
select(-contains("GameId"))
FilteredFrame[mapply(is.infinite, FilteredFrame)] <- NA ### TO REMOVE IF SO
FilteredFrame[is.na(FilteredFrame)] <- 0
Dataset<- JoinRepeatedPlayers(Data = FilteredFrame)
return(Dataset)
}
DfCorrection<- function(Data, vecindexes= WrongIndexInValDataset){
## Correction in the Dataset for the indexes passed set to 0
if(length(vecindexes)==0){return(Data)}
else{
for(i in 1:length(vecindexes)){
Indexes<- unlist(strsplit(vecindexes[1], ","))
row<- as.numeric(Indexes[1])
column<- as.numeric(Indexes[2])
Data[row, column]<-0
return(Data)
}}}
EvaluatedTimeVsValue<- function(ValMat, TimeMat){
# It returns the indexes of the matrix in ValMat that should be 0 in a string
WRONGVALUATIONindex <- integer(0)
for( i in 2:ncol(ValMat)){
Vec1<-TimeMat[,i]
Vec2<-ValMat[,i]
index<-which(Vec1==0)
which(Vec2[index]!=0)
Condition<-identical(Vec2[index],rep(0,length(index)))
# checking incoherences on time
if(Condition==TRUE){
}else{WRONGVALUATIONindex<-c(WRONGVALUATIONindex,paste0(which(Vec2[index]!=0),",",i))
}
}
return(WRONGVALUATIONindex)
}
suppressWarnings(main())
# There is one warning related to a join of columns where more than the joined columns are supplied
# No problem
require(reshape2)
require(forecast)
require(ggplot2)
#### Global variables
Boolean <- FALSE #Changing to TRUE if wanting to work with non-zero Data (reccommended)
NameVar <-""
NTOP<- 944
Season<-2007
SalariesCalc <- FALSE # Changing to True when scrapped Data is on the varible Salaries2007
loadpath<-"C:/Users/Carles/Desktop/MasterThesis/CodeThesis/CleanDatasets/"
RegularMatches<-82
path = "C:/Users/Carles/Desktop/MasterThesis/CodeThesis/"
### Loading Datasets
CDataset<-read.csv(paste0(loadpath, Season, "CDataset.csv"),check.names=FALSE)
TimeDataset<-read.csv(paste0(loadpath, Season, "TimeDataset.csv"),check.names=FALSE)
PlusMinusTimeDataset<-read.csv(paste0(loadpath, Season,"PlusMinusTimeDataset.csv"),check.names=FALSE)
PMDataset<-read.csv(paste0(loadpath, Season,"PMDataset.csv"),check.names=FALSE)
SecTimeDataset<-read.csv(paste0(loadpath, Season,"SecTimeDataset.csv"),check.names=FALSE)
CDataset<-CDataset[,2:length(CDataset)]
TimeDataset<-TimeDataset[,2:length(TimeDataset)]
PlusMinusTimeDataset<-PlusMinusTimeDataset[,2:length(PlusMinusTimeDataset)]
PMDataset<-PMDataset[,2:length(PMDataset)]
SecTimeDataset<-SecTimeDataset[,2:length(SecTimeDataset)]
lengthseries<-30
holdout<-5
###################
# I am going to take all data with more than 30 observations and put their
# first 30 observations in the following vector
DatasetsList<- list(CDataset, TimeDataset, PlusMinusTimeDataset, PMDataset)
GeneralNames<-c("Val", "ValTime", "PMTime", "PM")
AccuracyEvaluationData<- function(lengthseries=lengthseries,
holdout= holdout,
GeneralNames = GeneralNames,
DatasetList= DatasetsList){
######### It makes a forecast for for Players with more than lengthseries views,
#        and taking the first lengthseries observations
#        with holdout = houldout, and gives out several metrics accuracy
#########
## Args:
#     lengthseries: integer number that decides how long will be the serie to analyze
#     holdout: integer number values to predict
#     GeneralNames: vector of names to pass as definition of what is the metric of the Dataset about
#     DatasetList: List of data.frames with same colnames and rownames and dimensions
trainError<-data.frame()
testError<-data.frame()
for(Dataindex in 1:length(DatasetsList)){
Dataindex<-2
Dataset<- DatasetList[[Dataindex]]
print(paste0("Doing Dataset ",Dataindex, " out of ", length(DatasetList)))
TimseSeriesData<-list()
for(i in 2:ncol(Dataset)){
### The steps are:
#(1) Selecting the matches Played by that player
#    (if time played is 0 in the timeDataset, then that player has not played a match)
myData<-Dataset[,i]
mytime<- TimeDataset[,i]
MyTrueData<- myData[-which(mytime==0)]
TimseSeriesData[[i-1]]<- MyTrueData
}
lengthlst<-lapply(TimseSeriesData, length)
### I predict on the last 5 and the first 25 are for training
series <-list()
index <-  c()
counter<-0
for(i in 1:length(lengthlst)){
if((lengthlst[[i]]>lengthseries)==TRUE){
counter<-counter+1
series[[counter]]<- ts(TimseSeriesData[[i]][1:lengthseries])
index[counter]<- i # For the general number
}
}
seriesdata<-df <- data.frame(matrix(unlist(series), nrow=length(series), byrow=T),stringsAsFactors=FALSE)
summary(seriesdata)
forecasts <- lapply(series,function(foo) {
subseries <- ts(head(foo,length(foo)-holdout),start=start(foo),frequency=frequency(foo))
forecast(auto.arima(subseries),h=holdout)
} )
Meanforecasts <- lapply(series,function(foo) {
subseries <- ts(head(foo,length(foo)-holdout),start=start(foo),frequency=frequency(foo))
forecast(Arima(subseries, order = c(0,0,0)),h=holdout)
} )
result <- mapply(FUN=accuracy,f=forecasts,x=series,SIMPLIFY=FALSE)
resultComparison<- mapply(FUN=accuracy,f=Meanforecasts,x=series,SIMPLIFY=FALSE)
AccuracyMats <- AccuracyInMatrices(trainError=trainError,
testError = testError,
Name = paste0("Arima ",GeneralNames[Dataindex]),
result = result)
trainError<-AccuracyMats$TrainDataset
testError<- AccuracyMats$TestDataset
AccuracyMats <- AccuracyInMatrices(trainError=trainError,
testError = testError,
Name = paste0("Arima(0,0,0) ",GeneralNames[Dataindex]),
result = resultComparison)
trainError<-AccuracyMats$TrainDataset
testError<- AccuracyMats$TestDataset}
return(list(trainError=trainError, testError=testError))
}
AccuracyInMatrices<-function(trainError, testError,Name, result){
# name: variable just to say the name of the column to identify where that observations come from
# datasets trainError and testError are passed where the result will be given
# result is the accuracy result got from 'accuracy()' function
b<-result[[1]] # to extract column names and row names
for (type in 1:length(rownames(b))){
setType <- rownames(b)[type]
if(setType == "Training set"){
for(j in 1:length(colnames(b))){
name<- colnames(b)[j]
errtrain<- sapply(result, "[", setType, name)
if(j==1){smallDataset<-data.frame(errtrain)}
else{smallDataset<-cbind(smallDataset, errtrain)}
}
smallDataset<- cbind(smallDataset, Name)
colnames(smallDataset)<-c(colnames(b), "DataframeName")
if(all.equal(dim(trainError),c(0,0))==TRUE){
trainError<- smallDataset
colnames(trainError)<-c(colnames(b), "DataframeName")
}
else{trainError<-rbind(trainError, smallDataset)}
}
else if(setType == "Test set"){
for(j in 1:length(colnames(b))){
name<- colnames(b)[j]
errtest<- sapply(result, "[", setType, name)
if(j==1){smallTestDataset<-data.frame(errtest)}
else{smallTestDataset<-cbind(smallTestDataset, errtest)}
}
smallTestDataset<- cbind(smallTestDataset, Name)
colnames(smallTestDataset)<-c(colnames(b), "DataframeName")
if(all.equal(dim(testError),c(0,0))==TRUE){
testError<- smallTestDataset
colnames(testError)<-c(colnames(b), "DataframeName")
}
else{testError<-rbind(testError, smallTestDataset)}
}
else{ print("Not allocated to anywhere !")}
}
return(list(trainError= trainError,
testError= testError))
}
ErrorsForDatasets<-AccuracyEvaluationData(lengthseries=lengthseries,
holdout= holdout,
GeneralNames = GeneralNames,
DatasetList= DatasetsList)
require(reshape2)
require(forecast)
require(ggplot2)
#### Global variables
Boolean <- FALSE #Changing to TRUE if wanting to work with non-zero Data (reccommended)
NameVar <-""
NTOP<- 944
Season<-2007
SalariesCalc <- FALSE # Changing to True when scrapped Data is on the varible Salaries2007
loadpath<-"C:/Users/Carles/Desktop/MasterThesis/CodeThesis/CleanDatasets/"
RegularMatches<-82
path = "C:/Users/Carles/Desktop/MasterThesis/CodeThesis/"
### Loading Datasets
CDataset<-read.csv(paste0(loadpath, Season, "CDataset.csv"),check.names=FALSE)
TimeDataset<-read.csv(paste0(loadpath, Season, "TimeDataset.csv"),check.names=FALSE)
PlusMinusTimeDataset<-read.csv(paste0(loadpath, Season,"PlusMinusTimeDataset.csv"),check.names=FALSE)
PMDataset<-read.csv(paste0(loadpath, Season,"PMDataset.csv"),check.names=FALSE)
SecTimeDataset<-read.csv(paste0(loadpath, Season,"SecTimeDataset.csv"),check.names=FALSE)
CDataset<-CDataset[,2:length(CDataset)]
TimeDataset<-TimeDataset[,2:length(TimeDataset)]
PlusMinusTimeDataset<-PlusMinusTimeDataset[,2:length(PlusMinusTimeDataset)]
PMDataset<-PMDataset[,2:length(PMDataset)]
SecTimeDataset<-SecTimeDataset[,2:length(SecTimeDataset)]
lengthseries<-30
holdout<-5
###################
# I am going to take all data with more than 30 observations and put their
# first 30 observations in the following vector
DatasetsList<- list(CDataset, TimeDataset, PlusMinusTimeDataset, PMDataset)
GeneralNames<-c("Val", "ValTime", "PMTime", "PM")
AccuracyEvaluationData<- function(lengthseries=lengthseries,
holdout= holdout,
GeneralNames = GeneralNames,
DatasetList= DatasetsList){
######### It makes a forecast for for Players with more than lengthseries views,
#        and taking the first lengthseries observations
#        with holdout = houldout, and gives out several metrics accuracy
#########
## Args:
#     lengthseries: integer number that decides how long will be the serie to analyze
#     holdout: integer number values to predict
#     GeneralNames: vector of names to pass as definition of what is the metric of the Dataset about
#     DatasetList: List of data.frames with same colnames and rownames and dimensions
trainError<-data.frame()
testError<-data.frame()
for(Dataindex in 1:length(DatasetsList)){
Dataset<- DatasetList[[Dataindex]]
print(paste0("Doing Dataset ",Dataindex, " out of ", length(DatasetList)))
TimseSeriesData<-list()
for(i in 2:ncol(Dataset)){
### The steps are:
#(1) Selecting the matches Played by that player
#    (if time played is 0 in the timeDataset, then that player has not played a match)
myData<-Dataset[,i]
mytime<- TimeDataset[,i]
MyTrueData<- myData[-which(mytime==0)]
TimseSeriesData[[i-1]]<- MyTrueData
}
lengthlst<-lapply(TimseSeriesData, length)
### I predict on the last 5 and the first 25 are for training
series <-list()
index <-  c()
counter<-0
for(i in 1:length(lengthlst)){
if((lengthlst[[i]]>lengthseries)==TRUE){
counter<-counter+1
series[[counter]]<- ts(TimseSeriesData[[i]][1:lengthseries])
index[counter]<- i # For the general number
}
}
seriesdata<-df <- data.frame(matrix(unlist(series), nrow=length(series), byrow=T),stringsAsFactors=FALSE)
summary(seriesdata)
forecasts <- lapply(series,function(foo) {
subseries <- ts(head(foo,length(foo)-holdout),start=start(foo),frequency=frequency(foo))
forecast(auto.arima(subseries),h=holdout)
} )
Meanforecasts <- lapply(series,function(foo) {
subseries <- ts(head(foo,length(foo)-holdout),start=start(foo),frequency=frequency(foo))
forecast(Arima(subseries, order = c(0,0,0)),h=holdout)
} )
result <- mapply(FUN=accuracy,f=forecasts,x=series,SIMPLIFY=FALSE)
resultComparison<- mapply(FUN=accuracy,f=Meanforecasts,x=series,SIMPLIFY=FALSE)
AccuracyMats <- AccuracyInMatrices(trainError=trainError,
testError = testError,
Name = paste0("Arima ",GeneralNames[Dataindex]),
result = result)
trainError<-AccuracyMats$TrainDataset
testError<- AccuracyMats$TestDataset
AccuracyMats <- AccuracyInMatrices(trainError=trainError,
testError = testError,
Name = paste0("Arima(0,0,0) ",GeneralNames[Dataindex]),
result = resultComparison)
trainError<-AccuracyMats$TrainDataset
testError<- AccuracyMats$TestDataset}
return(list(trainError=trainError, testError=testError))
}
AccuracyInMatrices<-function(trainError, testError,Name, result){
# name: variable just to say the name of the column to identify where that observations come from
# datasets trainError and testError are passed where the result will be given
# result is the accuracy result got from 'accuracy()' function
b<-result[[1]] # to extract column names and row names
for (type in 1:length(rownames(b))){
setType <- rownames(b)[type]
if(setType == "Training set"){
for(j in 1:length(colnames(b))){
name<- colnames(b)[j]
errtrain<- sapply(result, "[", setType, name)
if(j==1){smallDataset<-data.frame(errtrain)}
else{smallDataset<-cbind(smallDataset, errtrain)}
}
smallDataset<- cbind(smallDataset, Name)
colnames(smallDataset)<-c(colnames(b), "DataframeName")
if(all.equal(dim(trainError),c(0,0))==TRUE){
trainError<- smallDataset
colnames(trainError)<-c(colnames(b), "DataframeName")
}
else{trainError<-rbind(trainError, smallDataset)}
}
else if(setType == "Test set"){
for(j in 1:length(colnames(b))){
name<- colnames(b)[j]
errtest<- sapply(result, "[", setType, name)
if(j==1){smallTestDataset<-data.frame(errtest)}
else{smallTestDataset<-cbind(smallTestDataset, errtest)}
}
smallTestDataset<- cbind(smallTestDataset, Name)
colnames(smallTestDataset)<-c(colnames(b), "DataframeName")
if(all.equal(dim(testError),c(0,0))==TRUE){
testError<- smallTestDataset
colnames(testError)<-c(colnames(b), "DataframeName")
}
else{testError<-rbind(testError, smallTestDataset)}
}
else{ print("Not allocated to anywhere !")}
}
return(list(trainError= trainError,
testError= testError))
}
ErrorsForDatasets<-AccuracyEvaluationData(lengthseries=lengthseries,
holdout= holdout,
GeneralNames = GeneralNames,
DatasetList= DatasetsList)
TrainErrorsforDatasets<-  ErrorsForDatasets$trainError
TestErrorsforDatasets<-  ErrorsForDatasets$testError
df2_melted<-melt(trainError,id.vars = "DataframeName")
###SHowing MAPE for prediction
ggplot(df2_melted)+
facet_grid(DataframeName~variable, drop = T, scales = "free")+
geom_histogram(aes(x=value, y=(..count..)/tapply(..count..,..PANEL..,sum)[..PANEL..]))
df2_melted<-melt(TrainErrorsforDatasets,id.vars = "DataframeName")
ErrorsForDatasets
require(reshape2)
require(forecast)
require(ggplot2)
#### Global variables
Boolean <- FALSE #Changing to TRUE if wanting to work with non-zero Data (reccommended)
NameVar <-""
NTOP<- 944
Season<-2007
SalariesCalc <- FALSE # Changing to True when scrapped Data is on the varible Salaries2007
loadpath<-"C:/Users/Carles/Desktop/MasterThesis/CodeThesis/CleanDatasets/"
RegularMatches<-82
path = "C:/Users/Carles/Desktop/MasterThesis/CodeThesis/"
### Loading Datasets
CDataset<-read.csv(paste0(loadpath, Season, "CDataset.csv"),check.names=FALSE)
TimeDataset<-read.csv(paste0(loadpath, Season, "TimeDataset.csv"),check.names=FALSE)
PlusMinusTimeDataset<-read.csv(paste0(loadpath, Season,"PlusMinusTimeDataset.csv"),check.names=FALSE)
PMDataset<-read.csv(paste0(loadpath, Season,"PMDataset.csv"),check.names=FALSE)
SecTimeDataset<-read.csv(paste0(loadpath, Season,"SecTimeDataset.csv"),check.names=FALSE)
CDataset<-CDataset[,2:length(CDataset)]
TimeDataset<-TimeDataset[,2:length(TimeDataset)]
PlusMinusTimeDataset<-PlusMinusTimeDataset[,2:length(PlusMinusTimeDataset)]
PMDataset<-PMDataset[,2:length(PMDataset)]
SecTimeDataset<-SecTimeDataset[,2:length(SecTimeDataset)]
lengthseries<-30
holdout<-5
###################
# I am going to take all data with more than 30 observations and put their
# first 30 observations in the following vector
DatasetsList<- list(CDataset, TimeDataset, PlusMinusTimeDataset, PMDataset)
GeneralNames<-c("Val", "ValTime", "PMTime", "PM")
AccuracyEvaluationData<- function(lengthseries=lengthseries,
holdout= holdout,
GeneralNames = GeneralNames,
DatasetList= DatasetsList){
######### It makes a forecast for for Players with more than lengthseries views,
#        and taking the first lengthseries observations
#        with holdout = houldout, and gives out several metrics accuracy
#########
## Args:
#     lengthseries: integer number that decides how long will be the serie to analyze
#     holdout: integer number values to predict
#     GeneralNames: vector of names to pass as definition of what is the metric of the Dataset about
#     DatasetList: List of data.frames with same colnames and rownames and dimensions
trainError<-data.frame()
testError<-data.frame()
for(Dataindex in 1:length(DatasetsList)){
Dataset<- DatasetList[[Dataindex]]
print(paste0("Doing Dataset ",Dataindex, " out of ", length(DatasetList)))
TimseSeriesData<-list()
for(i in 2:ncol(Dataset)){
### The steps are:
#(1) Selecting the matches Played by that player
#    (if time played is 0 in the timeDataset, then that player has not played a match)
myData<-Dataset[,i]
mytime<- TimeDataset[,i]
MyTrueData<- myData[-which(mytime==0)]
TimseSeriesData[[i-1]]<- MyTrueData
}
lengthlst<-lapply(TimseSeriesData, length)
### I predict on the last 5 and the first 25 are for training
series <-list()
index <-  c()
counter<-0
for(i in 1:length(lengthlst)){
if((lengthlst[[i]]>lengthseries)==TRUE){
counter<-counter+1
series[[counter]]<- ts(TimseSeriesData[[i]][1:lengthseries])
index[counter]<- i # For the general number
}
}
seriesdata<-df <- data.frame(matrix(unlist(series), nrow=length(series), byrow=T),stringsAsFactors=FALSE)
summary(seriesdata)
forecasts <- lapply(series,function(foo) {
subseries <- ts(head(foo,length(foo)-holdout),start=start(foo),frequency=frequency(foo))
forecast(auto.arima(subseries),h=holdout)
} )
Meanforecasts <- lapply(series,function(foo) {
subseries <- ts(head(foo,length(foo)-holdout),start=start(foo),frequency=frequency(foo))
forecast(Arima(subseries, order = c(0,0,0)),h=holdout)
} )
result <- mapply(FUN=accuracy,f=forecasts,x=series,SIMPLIFY=FALSE)
resultComparison<- mapply(FUN=accuracy,f=Meanforecasts,x=series,SIMPLIFY=FALSE)
AccuracyMats <- AccuracyInMatrices(trainError=trainError,
testError = testError,
Name = paste0("Arima ",GeneralNames[Dataindex]),
result = result)
trainError<-AccuracyMats$trainError
testError<- AccuracyMats$testError
AccuracyMats <- AccuracyInMatrices(trainError=trainError,
testError = testError,
Name = paste0("Arima(0,0,0) ",GeneralNames[Dataindex]),
result = resultComparison)
trainError<-AccuracyMats$trainError
testError<- AccuracyMats$testError
}
return(list(trainError=trainError, testError=testError))
}
AccuracyInMatrices<-function(trainError, testError,Name, result){
# name: variable just to say the name of the column to identify where that observations come from
# datasets trainError and testError are passed where the result will be given
# result is the accuracy result got from 'accuracy()' function
b<-result[[1]] # to extract column names and row names
for (type in 1:length(rownames(b))){
setType <- rownames(b)[type]
if(setType == "Training set"){
for(j in 1:length(colnames(b))){
name<- colnames(b)[j]
errtrain<- sapply(result, "[", setType, name)
if(j==1){smallDataset<-data.frame(errtrain)}
else{smallDataset<-cbind(smallDataset, errtrain)}
}
smallDataset<- cbind(smallDataset, Name)
colnames(smallDataset)<-c(colnames(b), "DataframeName")
if(all.equal(dim(trainError),c(0,0))==TRUE){
trainError<- smallDataset
colnames(trainError)<-c(colnames(b), "DataframeName")
}
else{trainError<-rbind(trainError, smallDataset)}
}
else if(setType == "Test set"){
for(j in 1:length(colnames(b))){
name<- colnames(b)[j]
errtest<- sapply(result, "[", setType, name)
if(j==1){smallTestDataset<-data.frame(errtest)}
else{smallTestDataset<-cbind(smallTestDataset, errtest)}
}
smallTestDataset<- cbind(smallTestDataset, Name)
colnames(smallTestDataset)<-c(colnames(b), "DataframeName")
if(all.equal(dim(testError),c(0,0))==TRUE){
testError<- smallTestDataset
colnames(testError)<-c(colnames(b), "DataframeName")
}
else{testError<-rbind(testError, smallTestDataset)}
}
else{ print("Not allocated to anywhere !")}
}
return(list(trainError= trainError,
testError= testError))
}
ErrorsForDatasets<-AccuracyEvaluationData(lengthseries=lengthseries,
holdout= holdout,
GeneralNames = GeneralNames,
DatasetList= DatasetsList)
TrainErrorsforDatasets<-  ErrorsForDatasets$trainError
TestErrorsforDatasets<-  ErrorsForDatasets$testError
df2_melted<-melt(TrainErrorsforDatasets,id.vars = "DataframeName")
###SHowing MAPE for prediction
ggplot(df2_melted)+
facet_grid(DataframeName~variable, drop = T, scales = "free")+
geom_histogram(aes(x=value, y=(..count..)/tapply(..count..,..PANEL..,sum)[..PANEL..]))
TrainErrorsforDatasets
ggplot(df2_melted)+
facet_grid(DataframeName~variable, drop = T, scales = "free")+
geom_histogram(aes(x=value, y=(..count..)/tapply(..count..,..PANEL..,sum)[..PANEL..]))
